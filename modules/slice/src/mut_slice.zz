using <string.h> as c_string;
using slice::{Slice};
using slice as roslice;

export struct MutSlice {
    u8 mut* mem;
    usize   size;
    usize   mut * at;
}

pub theory integrity(MutSlice mut*self) -> bool (
        safe(self->at)
    &&  safe(self->mem)
    &&  len(self->mem) >= self->size
    &&  *self->at <= self->size
    &&  *self->at <= len(self->mem)
)

export fn make(MutSlice new mut*self, u8 mut*mem, usize size, usize mut *at)
    where len(mem) >= size
    where safe(at)
    where *at < size
    model integrity(self)
    model len(mem) == len(self->mem)
    model *at == *self->at
    model at == self->at
{
    self->size = size;
    self->mem  = mem;
    self->at   = at;
    static_attest(self->size == len(self->mem));
}

export fn as_slice(MutSlice * self) -> Slice
    where   integrity(self)
    model   roslice::integrity(&return)
{
    let r = Slice {
        mem:    self->mem,
        size:   *self->at,
    };
    static_attest(roslice::integrity(&r));
    return r;
}


export fn append_slice(MutSlice mut * self, Slice *other) -> bool
    where   integrity(self)
    model   integrity(self)
{
    if *self->at >= self->size || other->size >  self->size || *self->at  > self->size - other->size {
        return false;
    }

    c_string::memcpy(self->mem + *self->at, other->mem, other->size);
    *self->at += other->size;
    static_attest(*self->at < len(self->mem));
    return true;
}

export fn append_bytes(MutSlice mut * self, u8 *b, usize l) -> bool
    where   len(b) >= l
    where   integrity(self)
    model   integrity(self)
{
    if *self->at >= self->size || l >  self->size || *self->at  > self->size - l {
        return false;
    }

    c_string::memcpy(self->mem + *self->at, b, l);
    *self->at += l;
    static_attest(*self->at < len(self->mem));
    return true;
}

export fn append_cstr(MutSlice mut * self, char *b) -> bool
    where   integrity(self)
    where   nullterm(b)
    model   integrity(self)
{
    let l = unsafe<usize>(c_string::strlen(b));
    static_attest(len(b) >= l);
    return append_bytes(self, (u8*)b, l);
}

/// push a single character
export fn push(MutSlice mut * self, u8 b) -> bool
    where   integrity(self)
    model   integrity(self)
{
    if self->size < 1 || *self->at > self->size - 1 {
        return false;
    }

    self->mem[*self->at] = b;
    *self->at += 1;

    return true;
}

export fn push16(MutSlice mut * self, u16 b) -> bool
    where   integrity(self)
    model   integrity(self)
{
    if self->size < 2 || *self->at > self->size - 2 {
        return false;
    }

    c_string::memcpy(self->mem + *self->at, &b, 2);
    *self->at += 2;

    return true;
}

export fn push32(MutSlice mut * self, u32 b) -> bool
    where   integrity(self)
    model   integrity(self)
{
    if self->size < 4 || *self->at > self->size - 4 {
        return false;
    }

    c_string::memcpy(self->mem + *self->at, &b, 4);
    *self->at += 4;

    return true;
}

export fn push64(MutSlice mut * self, u64 b) -> bool
    where   integrity(self)
    model   integrity(self)
{
    if self->size < 8 || *self->at > self->size - 8 {
        return false;
    }

    c_string::memcpy(self->mem + *self->at, &b, 8);
    *self->at += 8;

    return true;
}
