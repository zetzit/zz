using <stdio.h>::{printf};
using <stdlib.h>::{atoi};
using <string.h>::{strcmp, memset};
using err;
using buffer;

const usize MAX_DEPTH = 64;

export symbol ParseError;

pub enum ValueType {
    String,
    Object,
    Integer,
    Boolean,
    Array,
    Null,
}

export struct Value {
    ValueType t;
    char*   string;
    int     integer;
    usize   index;
}

enum ParserState {
    Document,
    Object,
    Key,
    PostKey,
    PreVal,
    StringVal,
    IntVal,
    BoolVal,
    NullVal,
    PostVal,
}

export closure Iter      (U *u, err::Err+et mut *e, Parser+pt mut* p, char *k, Value v);
export closure Pop       (U *u, err::Err+et mut *e, Parser+pt mut* p);

export struct U {
    Iter    it;
    Pop     pop;

    void mut*   user1;
    usize       user2;
}

struct ParserStack {
    ParserState     state;
    U               user;
    bool            in_array;
    usize           index;
}

export struct Parser+ {
    usize           col;
    usize           line;
    bool            esc;

    ParserStack     state[MAX_DEPTH];
    usize           depth;

    usize           keylen;
    buffer::Buffer+ mut capture;
}

export fn parser(Parser+tail mut new*self, err::Err+et mut *e, U u)
    where err::checked(*e)
    where tail > 1
    where safe(u.it)
{
    memset(self, 0, sizeof(Parser));
    buffer::clear(&self->capture);

    self->line  = 1;

    ((self->state)[0]).user   = u;
}

export fn next(Parser+tail mut*self, err::Err+et mut *e,  U u)
    where err::checked(*e)
    where safe(u.it)

{
    if self->depth >= MAX_DEPTH {
        err::fail(e, err::OutOfTail, "json structure too deep");
        return;
    }

    static_attest(self->depth < len(self->state));
    ParserStack mut * mut stack = &((self->state)[self->depth]);

    if stack->state != ParserState::Object && (stack->state != ParserState::PreVal || !stack->in_array) {
        err::fail(e, ParseError, "invalid parser state for next(), can only call when value is object or array");
    }

    ((self->state)[self->depth]).user   = u;
}

export fn push(Parser+tail mut *self, err::Err+et mut *e, char *str, usize strlen)
    @solver("yices2")
    where err::checked(*e)
    where len(str) >= strlen
    where tail > 2
{
    static_attest(buffer::integrity(&self->capture, tail));
    for (usize mut at = 0; at < strlen; at++) {
        self->col += 1;

        char mut ch = str[at];

        static_attest(self->depth < len(self->state));
        ParserState mut state = self->state[self->depth].state;

        if state == ParserState::Key ||  state == ParserState::StringVal {
            if ch == 92 && !self->esc {
                self->esc = true;
                continue;
            } else if ch == '"' && !self->esc {
                advance(self, e, ch);
                if err::check(e) {
                    return;
                }
            } else {
                if self->esc {
                    switch ch {
                        'n' => { ch = '\n'  }
                        92  => { ch = 92    }
                        'r' => { ch = '\r'  }
                        'f' => { ch = '\f'  }
                        'b' => { ch = '\b'  }
                        't' => { ch = '\t'  }
                        '"' => { ch = '"'   }
                        '/' => { ch = '/'   }
                        default => {
                            err::fail(e, ParseError, "invalid escape character '%c' at: %u:%u", ch, self->line, self->col);
                            return;
                        }
                    }
                }
                self->esc = false;
                if !(self->capture).push(ch) {
                    err::fail(e, err::OutOfTail, "buffer overflow at %u:%u", self->line, self->col);
                    return;
                }
            }
        } else {
            switch ch {
                '\n' => {
                    (self->line)++;
                    self->col = 0;
                    /*
                    if state == ParserState::Key || state == ParserState::StringVal {
                        if !buffer::push(&(self->capture), ch) {
                            err::fail(e, 10, "buffer overflow at %u:%u", self->line, self->col);
                            return;
                        }
                    }
                    */
                }
                '\t' , '\r' , ' ', 0 => {
                    /*
                    if state == ParserState::Key || state == ParserState::StringVal {
                        if !buffer::push(&(self->capture), ch) {
                            err::fail(e, 10, "buffer overflow at %u:%u", self->line, self->col);
                            return;
                        }
                    }
                    */
                    static_attest(err::checked(*e));
                    if state == ParserState::IntVal || state == ParserState::BoolVal || state == ParserState::NullVal {
                        advance(self, e, ch);
                    }
                }
                '{' , '[' , '}' , ']' , '"' , ':' , ',' => {
                    static_attest(err::checked(*e));
                    advance(self, e, ch);
                    if err::check(e) {
                        return;
                    }
                }
                default => {
                    if state == ParserState::PreVal && ((ch >= '0' && ch <= '9') || ch == '-' || ch == 't' || ch == 'f' || ch == 'n') {
                        advance(self, e, ch);
                        static_attest(self->depth < len(self->state));
                        state = ((self->state)[self->depth]).state;
                        if err::check(e) {
                            return;
                        }
                    }
                    static_attest(err::checked(*e));

                    if state == ParserState::IntVal || state == ParserState::BoolVal || state == ParserState::NullVal{
                        if !buffer::push(&(self->capture), ch) {
                            err::fail(e, err::OutOfTail, "buffer overflow at %u:%u", self->line, self->col);
                            return;
                        }
                    } else {
                        err::fail(e, ParseError, "unexpected '%c' at %u:%u while %u", ch, self->line, self->col, state);
                        return;
                    }
                }
            }
        }

    }
}

fn advance(Parser+tail mut *self, err::Err+et mut *e, char token)
    where err::checked(*e)
    where tail > 2
{
    static_attest(self->depth  < len(self->state));
    ParserStack mut * mut stack = &((self->state)[self->depth]);

    switch stack->state {
        ParserState::Document => {
            if token == '{' {
                 stack->state = ParserState::Object;
            } else {
                err::fail(e, ParseError, "unexpected '%c', expected { at %u:%u", token, self->line, self->col);
                return;
            }
        }
        ParserState::Object => {
            if token == '"' {
                stack->state = ParserState::Key;
                buffer::clear(&self->capture);
            } else if token == '}' {
                if self->depth > 0 {
                    (self->depth) -=1;
                    if stack->user.pop.fn != 0 {
                        static_attest(safe(stack->user.pop));
                        stack->user.pop(&stack->user, e, self);
                        if err::check(e) {
                            return;
                        }
                    }
                } else {
                    stack->state = ParserState::Document;
                }
            } else {
                err::fail(e, ParseError, "unexpected '%c', expected '\"' or } at %u:%u", token, self->line, self->col);
                return;
            }
        }
        ParserState::Key => {
            if token == '"' {
                stack->state = ParserState::PostKey;
            } else {
                err::fail(e, ParseError, "unexpected '%c', expected '\"' at %u:%u", token, self->line, self->col);
                return;
            }
        }
        ParserState::PostKey => {
            if token == ':' {
                stack->state = ParserState::PreVal;
                buffer::push(&(self->capture), 0);
                self->keylen = (self->capture).at;
            } else {
                err::fail(e, ParseError, "unexpected '%c', expected ':' at %u:%u", token, self->line, self->col);
                return;
            }
        }
        ParserState::PreVal => {
            if stack->in_array {
                self->capture.clear();
                self->capture.format("%d", self->state[self->depth].index);
                self->capture.push(0);
                self->keylen = self->capture.at;
            }
            if token == '"' {
                stack->state = ParserState::StringVal;
            } else if (token == 'n') {
                stack->state = ParserState::NullVal;
            } else if (token == 't' || token == 'f') {
                stack->state = ParserState::BoolVal;
            } else if (token >= '0' && token <= '9') || token == '-' {
                stack->state = ParserState::IntVal;
            } else if token == '{' {
                stack->state = ParserState::PostVal;
                if self->depth >= MAX_DEPTH - 1 {
                    err::fail(e, err::OutOfTail, "json structure too deep");
                    return;
                } else {
                    (self->depth)+=1;
                    ParserStack mut* previous_stack = stack;
                    stack = &((self->state)[self->depth]);
                    memset(stack, 0, sizeof(ParserStack));
                    stack->state = ParserState::Object;
                    if previous_stack->user.it.fn != 0 {
                        Iter de = previous_stack->user.it;
                        static_attest(safe(de));
                        Value val = Value{
                            index:  previous_stack->index,
                            t:      ValueType::Object,
                        };
                        de(&previous_stack->user, e, self, (self->capture).mem, val);
                        if err::check(e) {
                            return;
                        }
                    }
                    previous_stack->index += 1;
                }
            } else if token == '[' {
                stack->state = ParserState::PostVal;
                (self->depth)+=1;
                if self->depth >= MAX_DEPTH {
                    err::fail(e, err::OutOfTail, "json structure too deep");
                    return;
                } else {
                    ParserStack mut * previous_stack = stack;
                    stack = &((self->state)[self->depth]);
                    memset(stack, 0, sizeof(ParserStack));
                    stack->state = ParserState::PreVal;
                    stack->in_array = true;
                    if previous_stack->user.it.fn != 0 {
                        Iter de = previous_stack->user.it;
                        static_attest(safe(de));
                        Value val = Value{
                            index:  previous_stack->index,
                            t:      ValueType::Array,
                        };
                        de(&previous_stack->user, e, self, (self->capture).mem, val);
                        if err::check(e) {
                            return;
                        }
                    }
                    previous_stack->index += 1;
                }
            } else if token == ']' && stack->in_array {
                if self->depth > 0 {
                    (self->depth) -=1;
                    if stack->user.pop.fn != 0 {
                        static_attest(safe(stack->user.pop));
                        stack->user.pop(&stack->user, e, self);
                        if err::check(e) {
                            return;
                        }
                    }
                } else {
                    stack->state = ParserState::Document;
                }
            } else {
                err::fail(e, ParseError, "unexpected '%c', expected '\"' at %u:%u", token, self->line, self->col);
                return;
            }
        }
        ParserState::StringVal => {
            if token == '"' {
                stack->state = ParserState::PostVal;
                if stack->user.it.fn != 0 {
                    Iter de = stack->user.it;
                    static_attest(safe(de));
                    static_attest(self->keylen < len((self->capture).mem));
                    Value val = Value{
                        index:  stack->index,
                        t:      ValueType::String,
                        string: ((self->capture).mem + self->keylen),
                    };
                    de(&stack->user, e, self, (self->capture).mem, val);
                    if err::check(e) {
                        return;
                    }
                    stack->index += 1;
                }
            } else {
                err::fail(e, ParseError, "unexpected '%c', expected '\"' at %u:%u", token, self->line, self->col);
                return;
            }
        }
        ParserState::BoolVal , ParserState::NullVal => {
            if stack->user.it.fn != 0 {
                Iter de = stack->user.it;
                static_attest(safe(de));
                static_attest(self->keylen < len((self->capture).mem));

                ValueType mut t = ValueType::Boolean;
                if stack->state == ParserState::NullVal {
                    t = ValueType::Null;
                }

                Value val = Value{
                    index:      stack->index,
                    t:          t,
                    integer:    (self->capture.mem + self->keylen)[0] == 't',
                };
                de(&stack->user, e, self, (self->capture).mem, val);
                if err::check(e) { return; }
                stack->index += 1;
            }

            if token == ',' {
                if stack->in_array {
                    stack->state = ParserState::PreVal;
                } else {
                    stack->state = ParserState::Object;
                }
            } else if token == ' ' {
                stack->state = ParserState::PostVal;
            } else if (token == '}' && !stack->in_array) || (token == ']' && stack->in_array) {
                if self->depth > 0 {
                    (self->depth) -=1;
                    if stack->user.pop.fn != 0 {
                        static_attest(safe(stack->user.pop));
                        stack->user.pop(&stack->user, e, self);
                        if err::check(e) {
                            return;
                        }
                    }
                } else {
                    stack->state = ParserState::Document;
                }
            } else {
                err::fail(e, ParseError, "unexpected '%c', expected false or true or ',' or ' ' at %u:%u", token, self->line, self->col);
                return;
            }

        }
        ParserState::IntVal => {
            if stack->user.it.fn != 0 {
                Iter de = stack->user.it;
                static_attest(safe(de));
                static_attest(self->keylen < len((self->capture).mem));

                Value val = Value{
                    index:      stack->index,
                    t:          ValueType::Integer,
                    integer:    as<int>(atoi((self->capture).mem + self->keylen)),
                };
                de(&stack->user, e, self, (self->capture).mem, val);
                if err::check(e) { return; }
                stack->index += 1;
            }

            if token == ',' {
                if stack->in_array {
                    stack->state = ParserState::PreVal;
                } else {
                    stack->state = ParserState::Object;
                }
            } else if token == ' ' {
                stack->state = ParserState::PostVal;
            } else if (token == '}' && !stack->in_array) || (token == ']' && stack->in_array) {
                if self->depth > 0 {
                    (self->depth) -=1;
                    if stack->user.pop.fn != 0 {
                        static_attest(safe(stack->user.pop));
                        stack->user.pop(&stack->user, e, self);
                        if err::check(e) {
                            return;
                        }
                    }
                } else {
                    stack->state = ParserState::Document;
                }
            } else {
                err::fail(e, ParseError, "unexpected '%c', expected [0-9] or ',' or ' ' at %u:%u", token, self->line, self->col);
                return;
            }




        }
        ParserState::PostVal => {
            if token == ',' {
                if stack->in_array {
                    stack->state = ParserState::PreVal;
                } else {
                    stack->state = ParserState::Object;
                }
            } else if (token == '}' && !stack->in_array) || (token == ']' && stack->in_array) {
                if self->depth > 0 {
                    (self->depth) -=1;
                    if stack->user.pop.fn != 0 {
                        static_attest(safe(stack->user.pop));
                        stack->user.pop(&stack->user, e, self);
                        if err::check(e) {
                            return;
                        }
                    }
                } else {
                    stack->state = ParserState::Document;
                }
            } else {
                err::fail(e, ParseError, "unexpected '%c', expected ',' or '}' at %u:%u", token, self->line, self->col);
                return;
            }
        }
    }
}
